/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <cstrike>

char owner[256] = "STEAM_1:0:41511678";

ConVar g_cvDemo;
ConVar g_cvKnifeRound;
ConVar g_cvFullRounds;
ConVar g_cvPass;
ConVar g_cvConfig;
ConVar g_cvTeam1;
ConVar g_cvTeam2;

public Plugin:myinfo = 
{
	name = "zbot_test",
	author = "BigZ",
	description = "<- Description ->",
	version = "0.01",
	url = "<- URL ->"
}

public OnPluginStart()
{
	g_cvDemo = CreateConVar("zbot_demo", "0", "", FCVAR_PROTECTED, true, 0.0, true, 1.0);
	g_cvKnifeRound = CreateConVar("zbot_knife", "1", "", FCVAR_PROTECTED, true, 0.0, true, 1.0);
	g_cvFullRounds = CreateConVar("zbot_fullrounds", "0", "", FCVAR_PROTECTED, true, 0.0, true, 1.0);
	g_cvPass = CreateConVar("zbot_pass", "pcw", "", FCVAR_PROTECTED);
	g_cvConfig =  CreateConVar("zbot_config", "esl5on5.cfg", "", FCVAR_PROTECTED);
	g_cvTeam1 = CreateConVar("zbot_team1", "Team1", "", FCVAR_PROTECTED);
	g_cvTeam2 = CreateConVar("zbot_team2", "Team2", "", FCVAR_PROTECTED);
	AutoExecConfig(true, "config", "zbot_test");
	
	HookEvent("round_prestart", Event_RoundPreStart);
	HookEvent("round_poststart", Event_RoundPosStart);
	HookEvent("round_end", Event_RoundEnd);
	HookEvent("cs_match_end_restart", Event_MatchEndRestart);
	HookEvent("cs_pre_restart", Event_CsPreRestart);
	
	RegConsoleCmd("zbot_test", Command_Test);
}

public Action Command_Test(int client, int args)
{
	char arg[128];
	if(client)
	{
		PrintToChatAll("\x011\x022\x033\x044\x055\x066\x077\x088\x099\x0AA\x0BB\x0CC\x0DD\x0EE\x0FF");
	}
	if(args == 1)
	{
		GetCmdArg(1, arg, sizeof(arg));
		if(strcmp(arg, "load", false) == 0)
		{
			LoadMatch(client);
			return Plugin_Handled;
		}
		else if(strcmp(arg, "delete", false) == 0)
		{
			DeleteMatch(client);
			return Plugin_Handled;
		}
		return Plugin_Handled;
	}
	else if(args == 8)
	{
		char teamname1[256];
		GetCmdArg(1, teamname1, sizeof(teamname1));
		char teamname2[256];
		GetCmdArg(2, teamname2, sizeof(teamname2));
		char mapname[256];
		GetCmdArg(3, mapname, sizeof(mapname));
		char password[256];
		GetCmdArg(4, password, sizeof(password));
		char config[256];
		GetCmdArg(5, config, sizeof(config));
		char demo[256];
		GetCmdArg(6, demo, sizeof(demo));
		char frounds[256];
		GetCmdArg(7, frounds, sizeof(frounds));
		char kround[256];
		GetCmdArg(8, kround, sizeof(kround));
		CreateMatch(client, teamname1, teamname2, mapname, password, config, demo, frounds, kround);
		return Plugin_Handled;
	} else {
		PrintToConsole(client, "zbot_test team1 team2 map pass cfg demo frounds krounds");
		return Plugin_Handled;
	}
}

public Action Event_RoundPreStart(Event event, const char[] name, bool dontBroadcast)
{
	SendToOwner("ZBot: RoundPreStart has been fired!");
}

public Action Event_RoundPosStart(Event event, const char[] name, bool dontBroadcast)
{
	SendToOwner("ZBot: RoundPosStart has been fired!");
}

public Action Event_RoundEnd(Event event, const char[] name, bool dontBroadcast)
{
	int winner = event.GetInt("winner");
	int reason = event.GetInt("reason");
	char message[256];
	event.GetString("message", message, sizeof(message));
	
	char buffer[256];
	Format(buffer, sizeof(buffer), "ZBot: RoundEnd has been fired! winner: %d reason: %d message: %s", winner, reason, message);
	SendToOwner(buffer);
}

public Action Event_GameEnd(Event event, const char[] name, bool dontBroadcast)
{
	int winner = event.GetInt("winner");
	
	char buffer[256];
	Format(buffer, sizeof(buffer), "ZBot: RoundEnd has been fired! winner: %d", winner);
	SendToOwner(buffer);
}

public Action Event_MatchEndRestart(Event event, const char[] name, bool dontBroadcast)
{
	SendToOwner("ZBot: cs_match_end_restart has been fired!");
}

public Action Event_CsPreRestart(Event event, const char[] name, bool dontBroadcast)
{
	SendToOwner("ZBot: cs_pre_restart has been fired!");
}

public void CreateMatch(int client, const char[] teamname1, const char[] teamname2, const char[] mapname, const char[] password, const char[] config, const char[] demo, const char[] frounds, const char[] kround)
{	
	KeyValues kv = new KeyValues("MatchSet");
	kv.JumpToKey("Match", true);
	kv.SetString("Team1", teamname1);
	kv.SetString("Team2", teamname2);
	kv.SetString("Map", mapname);
	kv.SetString("Password", password);
	kv.SetString("Config", config);
	kv.SetString("Demo", demo);
	kv.SetString("FullRounds", frounds);
	kv.SetString("KnifeRound", kround);
	kv.Rewind();
	kv.ExportToFile("match.sav");
	delete kv;
	PrintToChat(client, "T1: %s T2: %s Map: %s Password: %s Config: %s Demo: %d FullRounds: %d KnifeRound: %d", teamname1, teamname2, mapname, password, config, demo, frounds, kround);
	return;
}

public void LoadMatch(int client)
{
	char teamname1[256];
	char teamname2[256];
	char mapname[256];
	char password[256];
	char config[256];
	char demo[256];
	char frounds[256];
	char kround[256];
	
	KeyValues kv = new KeyValues("MatchSet");
	kv.ImportFromFile("match.sav");
	if(!kv.JumpToKey("Match"))
	{
		return;
	}
	kv.GetString("Team1", teamname1, 256);
	kv.GetString("Team2", teamname2, 256);
	kv.GetString("Map", mapname, 256);
	kv.GetString("Password", password, 256);
	kv.GetString("Config", config, 256);
	kv.GetString("Demo", demo, 256);
	kv.GetString("FullRounds", frounds, 256);
	kv.GetString("KnifeRound", kround, 256);
	delete kv;
	PrintToChat(client, "T1: %s T2: %s Map: %s Password: %s Config: %s Demo: %d FullRounds: %d KnifeRound: %d", teamname1, teamname2, mapname, password, config, demo, frounds, kround);
	return;
}

public void DeleteMatch(int client)
{
	KeyValues kv = new KeyValues("MatchSet");
	kv.ImportFromFile("match.sav");
	if(!kv.JumpToKey("Match"))
	{
		PrintToChat(client, "Match has been deleted!")
		return;
	}
	kv.DeleteThis();
	kv.Rewind();
	kv.ExportToFile("match.sav");
	PrintToChat(client, "Deleted Match")
	delete kv;
}

public void SendToOwner(const char[] text)
{
	for(int i = 1; i < MaxClients; i++)
	{
		if(IsClientConnected(i))
		{
			char SteamId[256];
			GetClientAuthId(i, AuthId_Engine, SteamId, 256);
			//PrintToConsole(i, "Client: %d Auth %s", i, SteamId);
			if(strcmp(SteamId, owner, false) == 0) 
			{
				PrintToConsole(i, "%s", text);
			}
		} else {
			continue;
		}
	}
}